<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroid Shooter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            text-align: center;
        }
        canvas {
            background-color: #0a0a0a;
            border: 2px solid #3fff3f;
            box-shadow: 0 0 20px #3fff3f;
            image-rendering: pixelated;
        }
        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameCanvas {
            max-width: 100%;
            max-height: 100%;
        }
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.5);
        }
        h1 {
            font-size: 3rem;
            color: #fff;
            text-shadow: 0 0 10px #3fff3f, 0 0 20px #3fff3f;
            animation: flicker 1.5s infinite alternate;
        }
        @keyframes flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow:
                0 0 4px #fff,
                0 0 11px #fff,
                0 0 19px #fff,
                0 0 40px #0fa,
                0 0 80px #0fa,
                0 0 90px #0fa,
                0 0 100px #0fa,
                0 0 150px #0fa;
            }
            20%, 24%, 55% {        
                text-shadow: none;
            }
        }
        .start-btn, .restart-btn {
            background-color: #1a1a1a;
            border: 2px solid #3fff3f;
            color: #3fff3f;
            padding: 15px 30px;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 0 10px #3fff3f;
            transition: all 0.2s ease;
            margin-top: 20px;
        }
        .start-btn:hover, .restart-btn:hover {
            background-color: #3fff3f;
            color: #000;
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
            font-size: 1.5rem;
            color: #fff;
            text-shadow: 0 0 5px #3fff3f;
            pointer-events: none; /* So it doesn't block clicks on canvas */
        }
        #in-game-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }
        .control-btn {
            background-color: #1a1a1a;
            border: 2px solid #3fff3f;
            color: #3fff3f;
            padding: 10px 15px;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 0 0 10px #3fff3f;
            transition: all 0.2s ease;
        }
        .control-btn:hover {
            background-color: #3fff3f;
            color: #000;
        }
        .controls p {
            margin-bottom: 10px;
            letter-spacing: 2px;
        }
        .sensitivity-control {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 2rem;
            flex-direction: column;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 200px;
            height: 10px;
            background: #1a1a1a;
            outline: none;
            border: 2px solid #3fff3f;
            margin-top: 10px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            background: #3fff3f;
            cursor: pointer;
            box-shadow: 0 0 5px #3fff3f;
        }
        input[type="range"]::-moz-range-thumb {
            width: 25px;
            height: 25px;
            background: #3fff3f;
            cursor: pointer;
        }
        #notification {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(63, 255, 63, 0.2);
            color: #fff;
            padding: 20px 40px;
            font-size: 2rem;
            border: 2px solid #3fff3f;
            text-shadow: 0 0 10px #3fff3f;
            z-index: 100;
            animation: fadeInOut 4s ease-in-out;
        }
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            10%, 90% { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
    </style>
</head>
<body>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="startScreen" class="overlay">
            <h1>ASTEROID SHOOTER</h1>
            <div class="controls text-lg mt-4">
                <p class="font-bold underline">CONTROLS</p>
                <p>ARROW KEYS - MOVE</p>
                <p>SPACEBAR - SHOOT</p>
            </div>
            <div class="sensitivity-control">
                <label for="sensitivity" class="text-lg">SENSITIVITY</label>
                <input type="range" id="sensitivity" min="0.05" max="0.2" value="0.1" step="0.01">
            </div>
            <button class="start-btn">START GAME</button>
        </div>
        <div id="gameOverScreen" class="overlay" style="display: none;">
            <h1>GAME OVER</h1>
            <div id="finalScore" class="text-2xl mb-4"></div>
            <button class="restart-btn">RESTART</button>
        </div>
        <div id="ui-container" style="display: none;">
            <div id="score">SCORE: 0</div>
            <div id="lives">LIVES: 3</div>
        </div>
        <div id="in-game-controls" style="display: none;">
            <button id="restartInGameBtn" class="control-btn" tabindex="-1">RESTART</button>
            <button id="menuBtn" class="control-btn" tabindex="-1">MENU</button>
        </div>
        <div id="menuOverlay" class="overlay" style="display: none;">
            <h1 class="text-6xl mb-8">PAUSED</h1>
            <div class="flex flex-col gap-4">
                 <button id="resumeBtn" class="start-btn">RESUME</button>
                 <button id="menuRestartBtn" class="start-btn">RESTART</button>
                 <button id="mainMenuBtn" class="start-btn">MAIN MENU</button>
            </div>
        </div>
        <div id="notification" style="display: none;"></div>
    </div>

    <script>
        // Game setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let canvasWidth = window.innerWidth;
        let canvasHeight = window.innerHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        window.addEventListener('resize', () => {
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        });

        // Game constants
        const SHIP_SIZE = 30;
        const SHIP_THRUST = 0.1;
        let shipTurnSpeed = 0.1;
        const BULLET_SPEED = 7;
        const BULLET_MAX = 10;
        const ASTEROID_NUM = 1;
        const ASTEROID_SPEED = 1;
        const ASTEROID_SIZE = 100;
        const ASTEROID_VERTICES = 10;
        const ASTEROID_JAG = 0.4;
        const SHIP_INVINCIBILITY_DUR = 3; // in seconds
        const SHIP_BLINK_DUR = 0.2; // in seconds
        const SCORE_SKIN_1 = 500;
        const SCORE_SKIN_2 = 1500;

        // Game state variables
        let player;
        let bullets = [];
        let asteroids = [];
        let score = 0;
        let lives = 3;
        let level = 0;
        let gameOver = false;
        let isPaused = false;
        let animationFrameId = null;
        
        // DOM Elements
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const uiContainer = document.getElementById('ui-container');
        const scoreElement = document.getElementById('score');
        const livesElement = document.getElementById('lives');
        const finalScoreElement = document.getElementById('finalScore');
        const startButton = document.querySelector('.start-btn');
        const restartButton = document.querySelector('.restart-btn');
        const sensitivitySlider = document.getElementById('sensitivity');
        const inGameControls = document.getElementById('in-game-controls');
        const restartInGameBtn = document.getElementById('restartInGameBtn');
        const menuBtn = document.getElementById('menuBtn');
        const menuOverlay = document.getElementById('menuOverlay');
        const resumeBtn = document.getElementById('resumeBtn');
        const menuRestartBtn = document.getElementById('menuRestartBtn');
        const mainMenuBtn = document.getElementById('mainMenuBtn');
        const notificationElement = document.getElementById('notification');

        // Sound Effects
        let audioInitialized = false;
        let shootSound, explosionSound, thrustSound, playerExplosionSound;

        function initAudio() {
            if (audioInitialized) return;
            shootSound = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }
            }).toDestination();

            explosionSound = new Tone.NoiseSynth({
                noise: { type: 'white' },
                envelope: { attack: 0.005, decay: 0.2, sustain: 0, release: 0.1 }
            }).toDestination();
             playerExplosionSound = new Tone.NoiseSynth({
                noise: { type: 'pink' },
                envelope: { attack: 0.005, decay: 0.5, sustain: 0, release: 0.2 }
            }).toDestination();

            thrustSound = new Tone.NoiseSynth({
                noise: { type: 'pink' },
                envelope: { attack: 0.1, decay: 0.2, sustain: 1, release: 0.3 },
                volume: -20
            }).toDestination();
            audioInitialized = true;
        }


        // Input handling
        let keys = {
            up: false,
            left: false,
            right: false,
            space: false
        };

        sensitivitySlider.addEventListener('input', (e) => {
            shipTurnSpeed = parseFloat(e.target.value);
        });

        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'ArrowUp': 
                    keys.up = true; 
                    if (!isPaused && !gameOver) e.preventDefault();
                    break;
                case 'ArrowLeft': 
                    keys.left = true; 
                    if (!isPaused && !gameOver) e.preventDefault();
                    break;
                case 'ArrowRight': 
                    keys.right = true; 
                    if (!isPaused && !gameOver) e.preventDefault();
                    break;
                case 'Space': 
                    keys.space = true; 
                    if (!isPaused && !gameOver) e.preventDefault();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'ArrowUp': keys.up = false; break;
                case 'ArrowLeft': keys.left = false; break;
                case 'ArrowRight': keys.right = false; break;
                case 'Space': keys.space = false; break;
            }
        });

        // Player Ship Class
        class Player {
            constructor() {
                this.x = canvasWidth / 2;
                this.y = canvasHeight / 2;
                this.radius = SHIP_SIZE / 2;
                this.angle = 90 / 180 * Math.PI; // Pointing up
                this.rotation = 0;
                this.thrusting = false;
                this.thrust = { x: 0, y: 0 };
                this.canShoot = true;
                this.isInvincible = false;
                this.blinkTime = 0;
                this.blinkOn = true;
                this.skin = 0;
            }

            draw() {
                if (!this.blinkOn) {
                    return;
                }
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = SHIP_SIZE / 20;
                ctx.beginPath();

                switch(this.skin) {
                    case 1: // Interceptor Skin
                        ctx.moveTo( // Nose
                            this.x + this.radius * 1.2 * Math.cos(this.angle),
                            this.y - this.radius * 1.2 * Math.sin(this.angle)
                        );
                        ctx.lineTo( // Wing tip left
                            this.x - this.radius * (Math.cos(this.angle) + 1.5 * Math.sin(this.angle)),
                            this.y + this.radius * (Math.sin(this.angle) - 1.5 * Math.cos(this.angle))
                        );
                        ctx.lineTo( // Rear center
                            this.x - this.radius * 0.8 * Math.cos(this.angle),
                            this.y + this.radius * 0.8 * Math.sin(this.angle)
                        );
                        ctx.lineTo( // Wing tip right
                            this.x - this.radius * (Math.cos(this.angle) - 1.5 * Math.sin(this.angle)),
                            this.y + this.radius * (Math.sin(this.angle) + 1.5 * Math.cos(this.angle))
                        );
                        break;
                    case 2: // Destroyer Skin
                         ctx.moveTo( // Nose Left
                            this.x + this.radius * (Math.cos(this.angle) - 0.2 * Math.sin(this.angle)),
                            this.y - this.radius * (Math.sin(this.angle) + 0.2 * Math.cos(this.angle))
                        );
                        ctx.lineTo( // Nose Right
                            this.x + this.radius * (Math.cos(this.angle) + 0.2 * Math.sin(this.angle)),
                            this.y - this.radius * (Math.sin(this.angle) - 0.2 * Math.cos(this.angle))
                        );
                        ctx.lineTo( // Rear Right
                            this.x - this.radius * (Math.cos(this.angle) - 0.8 * Math.sin(this.angle)),
                            this.y + this.radius * (Math.sin(this.angle) + 0.8 * Math.cos(this.angle))
                        );
                        ctx.lineTo( // Rear Left
                            this.x - this.radius * (Math.cos(this.angle) + 0.8 * Math.sin(this.angle)),
                            this.y + this.radius * (Math.sin(this.angle) - 0.8 * Math.cos(this.angle))
                        );
                        break;
                    default: // Default Skin
                        // Nose of the ship
                        ctx.moveTo(
                            this.x + this.radius * Math.cos(this.angle),
                            this.y - this.radius * Math.sin(this.angle)
                        );
                        // Rear left
                        ctx.lineTo(
                            this.x - this.radius * (Math.cos(this.angle) + Math.sin(this.angle)),
                            this.y + this.radius * (Math.sin(this.angle) - Math.cos(this.angle))
                        );
                        // Rear right
                        ctx.lineTo(
                            this.x - this.radius * (Math.cos(this.angle) - Math.sin(this.angle)),
                            this.y + this.radius * (Math.sin(this.angle) + Math.cos(this.angle))
                        );
                        break;
                }
                
                ctx.closePath();
                ctx.stroke();

                // Draw thrust flame
                if(this.thrusting) {
                    ctx.fillStyle = '#ff8c00';
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = SHIP_SIZE / 10;
                    ctx.beginPath();
                    // Rear center
                    ctx.moveTo(
                        this.x - this.radius * (Math.cos(this.angle) - 0.5 * Math.sin(this.angle)),
                        this.y + this.radius * (Math.sin(this.angle) + 0.5 * Math.cos(this.angle))
                    );
                    ctx.lineTo(
                        this.x - this.radius * (Math.cos(this.angle) + 0.5 * Math.sin(this.angle)),
                        this.y + this.radius * (Math.sin(this.angle) - 0.5 * Math.cos(this.angle))
                    );
                    // Flame tip
                    ctx.lineTo(
                        this.x - this.radius * 1.5 * Math.cos(this.angle),
                        this.y + this.radius * 1.5 * Math.sin(this.angle)
                    );
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            }

            update() {
                this.angle += this.rotation;
                
                if (this.thrusting) {
                    this.thrust.x += SHIP_THRUST * Math.cos(this.angle);
                    this.thrust.y -= SHIP_THRUST * Math.sin(this.angle);
                } else {
                    // This makes the ship stop drifting when you let go of the key.
                    this.thrust.x = 0;
                    this.thrust.y = 0;
                }
                
                // Add a speed limit to prevent flying too fast
                const speed = Math.sqrt(this.thrust.x * this.thrust.x + this.thrust.y * this.thrust.y);
                const maxSpeed = 7; 
                if (speed > maxSpeed) {
                    this.thrust.x = (this.thrust.x / speed) * maxSpeed;
                    this.thrust.y = (this.thrust.y / speed) * maxSpeed;
                }

                this.x += this.thrust.x;
                this.y += this.thrust.y;
                
                // Handle screen wrap
                if (this.x < 0 - this.radius) this.x = canvasWidth + this.radius;
                if (this.x > canvasWidth + this.radius) this.x = 0 - this.radius;
                if (this.y < 0 - this.radius) this.y = canvasHeight + this.radius;
                if (this.y > canvasHeight + this.radius) this.y = 0 - this.radius;

                // Blinking when invincible
                if (this.isInvincible) {
                    this.blinkTime++;
                    if (this.blinkTime > SHIP_BLINK_DUR * 60) {
                        this.blinkOn = !this.blinkOn;
                        this.blinkTime = 0;
                    }
                } else {
                    this.blinkOn = true;
                }
            }

            shoot() {
                if (this.canShoot && bullets.length < BULLET_MAX) {
                    bullets.push(new Bullet(this.x, this.y, this.angle, this.skin));
                    shootSound?.triggerAttackRelease("G5", "32n");
                    this.canShoot = false;
                    setTimeout(() => this.canShoot = true, 250);
                }
            }
            
            setInvincible(duration) {
                this.isInvincible = true;
                setTimeout(() => {
                    this.isInvincible = false;
                }, duration * 1000);
            }
        }

        // Bullet Class
        class Bullet {
            constructor(x, y, angle, skin) {
                this.x = x + (SHIP_SIZE / 2) * Math.cos(angle);
                this.y = y - (SHIP_SIZE / 2) * Math.sin(angle);
                this.velX = BULLET_SPEED * Math.cos(angle);
                this.velY = -BULLET_SPEED * Math.sin(angle);
                this.radius = 2;
                this.life = 100; // frames
                this.skin = skin;
                this.angle = angle;
            }

            draw() {
                 switch(this.skin) {
                    case 1: // Laser Skin
                        ctx.fillStyle = '#3f9fff'; // Blue laser
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.rotate(-this.angle + Math.PI / 2);
                        ctx.fillRect(-2, -8, 4, 16);
                        ctx.restore();
                        break;
                    case 2: // Plasma Skin
                        ctx.fillStyle = '#ff3f3f'; // Red plasma core
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'rgba(255, 100, 100, 0.5)'; // Red glow
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    default: // Default bullet
                        ctx.fillStyle = '#3fff3f';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
            }
            
            update() {
                this.x += this.velX;
                this.y += this.velY;
                this.life--;
            }
        }

        // Asteroid Class
        class Asteroid {
            constructor(x, y, radius) {
                this.x = x || Math.random() * canvasWidth;
                this.y = y || Math.random() * canvasHeight;
                this.radius = radius || ASTEROID_SIZE / 2;
                this.speed = ASTEROID_SPEED;
                this.angle = Math.random() * Math.PI * 2;
                this.velX = Math.random() * this.speed - this.speed/2;
                this.velY = Math.random() * this.speed - this.speed/2;
                this.vertices = Math.floor(Math.random() * (ASTEROID_VERTICES + 1) + ASTEROID_VERTICES / 2);
                this.offsets = [];
                for(let i = 0; i < this.vertices; i++) {
                    this.offsets.push(Math.random() * ASTEROID_JAG * 2 + 1 - ASTEROID_JAG);
                }
            }

            draw() {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(
                    this.x + this.radius * this.offsets[0] * Math.cos(this.angle),
                    this.y + this.radius * this.offsets[0] * Math.sin(this.angle)
                );
                for (let i = 1; i < this.vertices; i++) {
                    ctx.lineTo(
                        this.x + this.radius * this.offsets[i] * Math.cos(this.angle + i * Math.PI * 2 / this.vertices),
                        this.y + this.radius * this.offsets[i] * Math.sin(this.angle + i * Math.PI * 2 / this.vertices)
                    );
                }
                ctx.closePath();
                ctx.stroke();
            }

            update() {
                this.x += this.velX;
                this.y += this.velY;
                
                // Handle screen wrap
                if (this.x < 0 - this.radius) this.x = canvasWidth + this.radius;
                if (this.x > canvasWidth + this.radius) this.x = 0 - this.radius;
                if (this.y < 0 - this.radius) this.y = canvasHeight + this.radius;
                if (this.y > canvasHeight + this.radius) this.y = 0 - this.radius;
            }
        }

        // Game Functions
        function createAsteroids() {
            asteroids = [];
            let asteroidsCount = ASTEROID_NUM + level;
            for (let i = 0; i < asteroidsCount; i++) {
                let x, y;
                 // Ensure asteroids don't spawn on top of the player
                do {
                    x = Math.random() * canvasWidth;
                    y = Math.random() * canvasHeight;
                } while (distBetweenPoints(player.x, player.y, x, y) < ASTEROID_SIZE * 2);
                asteroids.push(new Asteroid(x, y, ASTEROID_SIZE / 2));
            }
        }

        function distBetweenPoints(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function handleCollisions() {
             // Player vs Asteroids
            for (let i = asteroids.length - 1; i >= 0; i--) {
                if (!player.isInvincible && distBetweenPoints(player.x, player.y, asteroids[i].x, asteroids[i].y) < player.radius + asteroids[i].radius) {
                    playerHit();
                }
            }

            // Bullets vs Asteroids
            for (let i = asteroids.length - 1; i >= 0; i--) {
                for (let j = bullets.length - 1; j >= 0; j--) {
                    if (distBetweenPoints(asteroids[i].x, asteroids[i].y, bullets[j].x, bullets[j].y) < asteroids[i].radius) {
                        
                        // Destroy asteroid and bullet
                        let scoreGained = 0;
                        if (asteroids[i].radius > ASTEROID_SIZE / 4) {
                            scoreGained = 20;
                            // Break into smaller asteroids
                            asteroids.push(new Asteroid(asteroids[i].x, asteroids[i].y, asteroids[i].radius / 2));
                            asteroids.push(new Asteroid(asteroids[i].x, asteroids[i].y, asteroids[i].radius / 2));
                        } else {
                            scoreGained = 50;
                        }
                        
                        explosionSound?.triggerAttackRelease("8n");

                        asteroids.splice(i, 1);
                        bullets.splice(j, 1);
                        updateScore(scoreGained);
                        break; // Exit inner loop to avoid errors
                    }
                }
            }
        }

        function playerHit() {
            playerExplosionSound?.triggerAttackRelease("4n");
            lives--;
            updateLives();
            if (lives <= 0) {
                endGame();
            } else {
                player.x = canvasWidth / 2;
                player.y = canvasHeight / 2;
                player.thrust = {x: 0, y: 0};
                player.setInvincible(SHIP_INVINCIBILITY_DUR);
            }
        }
        
        function updateScore(points) {
            score += points;
            scoreElement.textContent = `SCORE: ${score}`;
            checkSkinUnlock();
        }

        function updateLives() {
            livesElement.textContent = `LIVES: ${lives}`;
        }
        
        function checkSkinUnlock() {
            let newSkin = 0;
            if (score >= SCORE_SKIN_2) {
                newSkin = 2;
            } else if (score >= SCORE_SKIN_1) {
                newSkin = 1;
            }

            if (newSkin > player.skin) {
                player.skin = newSkin;
                showUnlockMessage(`SKIN SET ${player.skin + 1} UNLOCKED!`);
            }
        }

        function showUnlockMessage(message) {
            notificationElement.textContent = message;
            notificationElement.style.display = 'block';
            // Reset animation
            notificationElement.style.animation = 'none';
            notificationElement.offsetHeight; /* trigger reflow */
            notificationElement.style.animation = ''; 
            setTimeout(() => {
                notificationElement.style.display = 'none';
            }, 4000);
        }

        function newLevel() {
            level++;
            createAsteroids();
        }

        function init() {
            player = new Player();
            score = 0;
            lives = 3;
            level = 0;
            gameOver = false;
            bullets = [];
            asteroids = [];
            createAsteroids();
            updateScore(0);
            updateLives();
        }

        async function startGame() {
            if (Tone.context.state !== 'running') {
                await Tone.start();
            }
            // Cancel any previous game loop to prevent duplicates
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            initAudio();
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            uiContainer.style.display = 'flex';
            inGameControls.style.display = 'flex';
            isPaused = false;
            menuOverlay.style.display = 'none';
            init();
            gameLoop();
        }

        function endGame() {
            gameOver = true;
            cancelAnimationFrame(animationFrameId);
            uiContainer.style.display = 'none';
            inGameControls.style.display = 'none';
            thrustSound?.triggerRelease();
            finalScoreElement.textContent = `YOUR SCORE: ${score}`;
            gameOverScreen.style.display = 'flex';
        }

        function toggleMenu() {
            isPaused = !isPaused;
            if (isPaused) {
                menuOverlay.style.display = 'flex';
                thrustSound?.triggerRelease();
            } else {
                menuOverlay.style.display = 'none';
            }
        }

        function goToMenu() {
            gameOver = true;
            cancelAnimationFrame(animationFrameId);
            isPaused = false;
            uiContainer.style.display = 'none';
            inGameControls.style.display = 'none';
            menuOverlay.style.display = 'none';
            gameOverScreen.style.display = 'none';
            startScreen.style.display = 'flex';
            thrustSound?.triggerRelease();
        }

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        restartInGameBtn.addEventListener('click', startGame);
        menuBtn.addEventListener('click', toggleMenu);
        resumeBtn.addEventListener('click', toggleMenu);
        menuRestartBtn.addEventListener('click', startGame);
        mainMenuBtn.addEventListener('click', goToMenu);

        // Game Loop
        function gameLoop() {
            // If the game is over, stop the loop entirely.
            if (gameOver) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            // If the game is NOT paused, update and draw everything.
            if (!isPaused) {
                // Handle player input
                player.rotation = keys.right ? shipTurnSpeed : keys.left ? -shipTurnSpeed : 0;
                player.thrusting = keys.up;
                if (keys.space) player.shoot();

                // Handle thrust sound
                if (player.thrusting && thrustSound?.state !== 'started') {
                    thrustSound?.triggerAttack();
                } else if (!player.thrusting && thrustSound?.state === 'started') {
                    thrustSound?.triggerRelease();
                }

                // Update game objects
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                
                player.update();
                player.draw();

                for (let i = bullets.length - 1; i >= 0; i--) {
                    bullets[i].update();
                    bullets[i].draw();
                    if (bullets[i].life <= 0) {
                        bullets.splice(i, 1);
                    }
                }

                for (let i = 0; i < asteroids.length; i++) {
                    asteroids[i].update();
                    asteroids[i].draw();
                }
                
                handleCollisions();

                // Check for new level
                if (asteroids.length === 0) {
                    newLevel();
                }
            }

            // Regardless of pause state, keep the loop queued for the next frame
            animationFrameId = requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>








